# Контрольні питання

1. **В чому полягає різниця між ключовими та зарезервованими словами?**

   * **Ключові слова** — слова мови з визначеним синтаксичним значенням (наприклад, `class`, `public`). Їх не можна використовувати як ідентифікатори.
   * **Зарезервовані слова** — слова, які зарезервовані для можливого майбутнього використання, але зараз можуть не мати семантики; також їх не можна використовувати як імена.

---

2. **Які примітивні типи даних Ви знаєте? Наведіть приклади ефективного використання.**

   * `byte` (8-біт): наприклад упаковка великих масивів даних, передача відео та зображень через інтернет, бінарні файли невеликих значень.
   * `short` (16-біт): дані з малим діапазоном, пам’яттєво чутливі структури (рідко використовується).
   * `int` (32-біт): загальні цілі числа — рахунок у матчі, довжина файлу в байтах (якщо помірні), індекси масивів.
   * `long` (64-біт): великі цілі — кількість мілісекунд з епохи, маса чи великі лічильники.
   * `float` (32-біт плаваючої крапки): економія пам’яті, графіка/GPU, коли точність не критична.
   * `double` (64-біт плаваючої крапки): стандарт для чисел з плаваючою комою — фінанси з округленням (хоч краще BigDecimal).
   * `char` (16-біт, UTF-16 код одиниці): символи/символьні операції.
   * `boolean`: логічні значення (умови, прапори).

---

3. **Що таке знакові та беззнакові типи? До якої групи відноситься кожен з примітивних типів даних?**

   * **Знакові** — можуть представляти додатні й від’ємні значення (two’s complement): `byte`, `short`, `int`, `long`, `float`, `double`.
   * **Беззнакові** — тільки невід’ємні; у Java лише `char` вважається беззнаковим (0..65535). `boolean` — логічний (не числовий).
   * Примітивні цілі числа (окрім `char`) — знакові.

---

4. **Яке максимальне число можна записати у змінну типу short, char, int, long?**

   * `short` → **32767** (2¹⁵−1).
   * `char` → **65535** (0..2¹⁶−1).
   * `int` → **2147483647** (2³¹−1).
   * `long` → **9223372036854775807** (2⁶³−1).

---

5. **Чому `byte` має діапазон -128..127? Чому від’ємних значень більше ніж додатних?**

   * Через **8-бітну two’s-complement** репрезентацію: діапазон = −2⁷ .. 2⁷−1 = −128..127.
   * По кількості значень від’ємних і невід’ємних рівно по 128 кожне; проте по **модулю** найменше значення (−128) не має позитивного відповідника (+128), тому здається «одне додаткове» від’ємне за величиною.

---

6. **Що таке система числення? Як переводити значення між системами?**

   * **Система числення** — спосіб представлення чисел з основою (база) `b` (наприклад, двійкова b=2, десяткова b=10, шістнадцяткова b=16).
   * **Переведення цілої частини**: ділення на нову базу з записом залишків (знизу вгору).
   * **Переведення дробової частини**: множення дробу на базу, ціла частина — цифра, повторювати.
   * Для швидкості між двійковою/шістнадцятковою/восьмеричною часто використовують групування біт (4 біт ↔ 1 hex).

---

7. **Що таке «доповняльний код» (two’s complement)?**

   * Метод представлення від’ємних чисел у бінарі: для отримання −N інвертують біти N і додають 1. Забезпечує зручну арифметику (однотипне додавання/віднімання), є стандартом для знакових цілих.

---

8. **Пояснити результат:**

```java
int a = 2_000_000_000;
int b = 2_000_000_000;
int c = a + b;
System.out.println(c);
```

* `a+b = 4_000_000_000`, що перевищує `Integer.MAX_VALUE` → **переповнення (overflow)** modulo 2³². Результат = **-294967296**. JVM нічого не повідомляє — просто відбувається обгортання.

---

9. **Чим `float` відрізняється від `double`?**

   * `float` — 32 біт (менше точності \~7 значущих цифр).
   * `double` — 64 біт (більша точність \~15–16 значущих цифр).
   * `double` — стандартний вибір; `float` — коли потрібна економія пам’яті або сумісність з апаратурою.

---

10. **Що таке число з рухомою комою? Що таке мантиса та степінь?**

* Число з рухомою комою = представлення виду `± mantissa × base^exponent`.
* **Мантиса (significand)** — значущі цифри числа.
* **Степінь (exponent)** — показник (скейл), який зсуває мантису вліво/вправо.

---

11. **Що таке `Double.NaN`?**

* `NaN` = *Not-a-Number* — спеціальне значення, що позначає невизначений/нечисловий результат (наприклад `0.0/0.0`, `sqrt(-1)`).

---

12. **Пояснити результат:**

```java
System.out.println(Double.NaN == Double.NaN);
```

* Друкує **false**. За стандартом IEEE NaN не рівний нічому, навіть собі. Для перевірки використовують `Double.isNaN(x)`.

---

13. **Преінкремент vs постінкремент. Приклади різних результатів.**

* `++i` (пре) — спочатку інкремент, потім повертає нове значення.
* `i++` (пост) — повертає старе значення, потім інкрементує.
* Приклад:

  ```java
  int i = 0;
  int a = ++i; // a=1, i=1
  i = 0;
  int b = i++; // b=0, i=1
  ```
* У виразах з використанням індексів/операцій (`arr[++i]` vs `arr[i++]`) результат відрізнятиметься.

---

14. **В чому різниця між логічною та побітовою операцією AND? Чому `&` є в обох варіантах, а `&&` — тільки логічна?**

* **Побітова `&`** — працює над бітами цілих типів; якщо застосована до boolean — виконує логічний AND **без** короткозамикання (обидва операнди завжди обчислюються).
* **Логічна `&&`** — працює тільки з boolean і є **короткозамкнутою**: правий операнд не обчислюється якщо лівий `false`.
* `&` існує двозначно (і як bitwise для чисел, і як non-short-circuit для boolean); `&&` — лише логічний з оптимізацією короткого замикання.

---

15. **В чому різниця між OR та XOR?**

* **OR (`|` / `||`)** — істина, якщо хоча б один операнд істинний.
* **XOR (`^`)** — істина, якщо лише **один** з операндів істинний (різність).
* Для бітових типів операції застосовуються по біту.

---

16. **Проаналізувати фрагмент, передбачити результат, пояснити.**

```java
boolean a = true && false | false;
System.out.println(a = false);

boolean b = true && false || false;
System.out.println(b = true);
```

* Операторна дія: `&&` виконуються першими → `true && false` дає `false`.
* Перший рядок: `(true && false) | false` → `false | false` → `false`. Потім в `println` знаходиться присвоєння `a = false`, воно присвоює `false` і друкує `false`.
* Другий: `(true && false) || false` → `false || false` → `false`. Потім `println(b = true)` — присвоює `true` бінарній змінній `b` і друкує `true`.
* **Вивід:**

  ```
  false
  true
  ```
* Пояснення: різниця між `|`/`||` і присвоєнням у `println` — в тому, що оператори логіки дають проміжні `false`, але дубль-присвоєння в `println` змінює і друкує нове значення.