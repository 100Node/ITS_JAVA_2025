# Михайлишин Захар ЦК-31 

## 1. Що таке структурне програмування?

Структурне програмування - це парадигма програмування, яка базується на використанні трьох основних управляючих структур: послідовність, розгалуження та цикли. Воно передбачає розбиття складної задачі на більш прості підзадачі та створення програм з чіткою логічною структурою без використання безумовних переходів (goto).

## 2. Основні конструкції структурного програмування:

* **Послідовність (sequence)** - виконання інструкцій одна за одною
* **Розгалуження (selection)** - умовні оператори (if-else, switch)
* **Цикли (iteration)** - повторення блоків коду (while, do-while, for)

## 3. Основні принципи структурного програмування:

* **Модульність** - розбиття програми на незалежні модулі
* **Ієрархічність** - організація модулів у вигляді ієрархії
* **Використання тільки трьох управляючих структур**
* **Один вхід - один вихід** для кожного блоку коду
* **Заборона goto** - уникнення безумовних переходів
* **Зверху-вниз проектування**

## 4. Чому не радять використовувати GOTO?

GOTO створює **"спагетті-код"** - заплутані програми з непередбачуваними переходами. Проблеми:

* Складність розуміння логіки програми
* Важкість налагодження та тестування
* Порушення структури програми
* Неможливість використання автоматичної оптимізації
* Складність підтримки та модифікації

В Java GOTO відсутній для забезпечення чистоти коду та структурності.

## 5. Що таке спагеті-код?

Спагетті-код - це програма з заплутаною, неструктурованою логікою, де важко простежити потік виконання. Назва походить від схожості з заплутаними макаронами. Характеризується:

* Хаотичними переходами між частинами коду
* Відсутністю чіткої структури
* Складністю розуміння та підтримки
* Великою кількістю goto або еквівалентних конструкцій

## 6. Проектування зверху-вниз та його переваги:

**Проектування зверху-вниз (top-down design)** - методологія, де спочатку визначається загальна структура системи, потім поступово деталізується кожен компонент.

**Переваги:**

* Краще розуміння загальної архітектури
* Легше планування та контроль розробки
* Зменшення складності через декомпозицію
* Можливість паралельної роботи над модулями
* Легше тестування окремих компонентів

## 7. Область видимості ідентифікатора:

Область видимості (scope) - це частина програми, де ідентифікатор (змінна, метод, клас) доступний для використання. В Java існують:

* **Блокова область видимості** - в межах блоку {}
* **Область видимості методу** - параметри та локальні змінні
* **Область видимості класу** - поля та методи класу
* **Область видимості пакету** - default модифікатор доступу

## 8. Блок та його вплив на область видимості:

**Блок** - це група операторів, укладена в фігурні дужки `{}`.

**Вплив на область видимості:**

* Змінні, оголошені в блоці, доступні тільки в цьому блоці
* Після завершення блоку змінні знищуються
* Внутрішні блоки можуть звертатися до змінних зовнішніх блоків
* Неможливо оголосити змінну з тією ж назвою в тому ж блоку

## 9. Приклади використання умовних конструкцій:

**if:**

```java
if (temperature > 0) {
    System.out.println("Плюсова температура");
}
```

**if-else:**

```java
if (age >= 18) {
    System.out.println("Повнолітній");
} else {
    System.out.println("Неповнолітній");
}
```

**ланцюги if-else if:**

```java
if (grade >= 90) {
    System.out.println("Відмінно");
} else if (grade >= 70) {
    System.out.println("Добре");
} else if (grade >= 50) {
    System.out.println("Задовільно");
} else {
    System.out.println("Незадовільно");
}
```

**switch:**

```java
switch (dayOfWeek) {
    case 1: System.out.println("Понеділок"); break;
    case 2: System.out.println("Вівторок"); break;
    // ...
    default: System.out.println("Невірний день");
}
```

**тернарна операція ?:**

```java
String result = (x > 0) ? "Позитивне" : "Не позитивне";
int max = (a > b) ? a : b;
```

## 10. Приклади використання циклів:

**while:**

```java
// Коли не знаємо точну кількість ітерацій
while (scanner.hasNextLine()) {
    String line = scanner.nextLine();
    processLine(line);
}
```

**do-while:**

```java
// Коли треба виконати хоча б один раз
int number;
do {
    System.out.print("Введіть число від 1 до 10: ");
    number = scanner.nextInt();
} while (number < 1 || number > 10);
```

**for:**

```java
// Коли знаємо точну кількість ітерацій
for (int i = 0; i < array.length; i++) {
    System.out.println(array[i]);
}
```

## 11. Різниця між break та continue:

**break:**

* Повністю виходить з циклу
* Передає управління наступному оператору після циклу
* Може використовуватися з мітками для виходу з вкладених циклів

**continue:**

* Пропускає решту поточної ітерації
* Переходить до наступної ітерації циклу
* Не виходить з циклу повністю

```java
for (int i = 1; i <= 10; i++) {
    if (i == 5) continue;  // Пропустить 5
    if (i == 8) break;     // Вийде з циклу на 8
    System.out.println(i); // Надрукує: 1,2,3,4,6,7
}
```

## 12. Навіщо мітки в Java без goto?

Мітки потрібні для:

* **Виходу з вкладених циклів:** `break label;`
* **Переходу до наступної ітерації зовнішнього циклу:** `continue label;`

```java
outer: for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break outer; // Вихід з обох циклів
        }
        System.out.println(i + "," + j);
    }
}
```

## 13. Аналіз коду з присвоєнням в if:

```java
boolean a = false;
boolean b = false;      
if (a=false) {              // ПРИСВОЄННЯ, не порівняння!
    System.out.println("a is false");
} 
if (b=true) {               // ПРИСВОЄННЯ!
    System.out.println("b is true");
}
if (a=b) {                  // ПРИСВОЄННЯ!
    System.out.println("a = b");
}
```

**Результат:**

```
b is true
a = b
```

**Пояснення:**

* `if (a=false)` - присвоює `a` значення `false`, умова `false`, блок не виконується
* `if (b=true)` - присвоює `b` значення `true`, умова `true`, виконується
* `if (a=b)` - присвоює `a` значення `b` (`true`), умова `true`, виконується

## 14. Аналіз коду з switch без break:

```java
int a = 1;
a++;        // a = 2
++a;        // a = 3
switch(a) {
    case 1: System.out.println("1");
    case 2: System.out.println("2");
    case 3: System.out.println("3");    // Виконується
    case 4: System.out.println("4");    // Виконується (fall-through)
}
```

**Результат:**

```
3
4
```

**Пояснення:**

* `a` стає рівним 3
* Виконується `case 3:`
* Через відсутність `break` виконання "провалюється" в `case 4:`

## 15. Аналіз коду з цілочисельним діленням:

```java
double sum = 0;              
for(int i=1; i<10; i++) {
    sum = sum + 1/i;          // ЦІЛОЧИСЕЛЬНЕ ДІЛЕННЯ!
}
System.out.println(sum > 1);
```

**Результат:** `false`

**Пояснення:**

* `1/i` - це цілочисельне ділення, бо обидва операнди `int`
* `1/1 = 1`, `1/2 = 0`, `1/3 = 0`, і т.д.
* `sum = 1.0` (тільки перший доданок не нуль)
* `1.0 > 1` дає `false`

**Правильно було б:** `sum = sum + 1.0/i;` або `sum = sum + (double)1/i;`
